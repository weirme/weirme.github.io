<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://weirme.github.io/</id><title>weirme</title><subtitle>weirme's personal blog, powered by Jekyll and Github pages.</subtitle> <updated>2022-05-27T23:02:40+08:00</updated> <author> <name>weirme</name> <uri>https://weirme.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://weirme.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://weirme.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 weirme </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>资源管理</title><link href="https://weirme.github.io/posts/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" rel="alternate" type="text/html" title="资源管理" /><published>2022-05-18T10:17:00+08:00</published> <updated>2022-05-18T10:17:00+08:00</updated> <id>https://weirme.github.io/posts/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</id> <content src="https://weirme.github.io/posts/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" /> <author> <name>weirme</name> </author> <category term="Notes" /> <category term="C/C++" /> <summary> 以对象管理资源 当我们向系统申请某一笔资源后, 应该立刻在同一语句内用它来初始化某个管理对象. 如果有下面这个工厂函数用来动态分配一个资源, 并返回指向资源的指针: Resource* create_resource(); 大部分时候我们可以通过智能指针很好的管理资源, 例如下面的代码: std::shared_ptr&amp;lt;Resource&amp;gt; ptr(create_resource()); 这样做的好处是将返回的指针放入智能指针对象中进行管理, 这样当该智能指针对象的生存期结束后, 将会在其析构函数中自动释放其持有的资源. 如果不这么做, 用户就需要自己通过 delete 来释放资源, 这会明显增加内存泄漏的风险. 另外值得注意的是, 不要试图用智能指针去管理动态分配的数组, 例如下面的代码: std::shared_ptr&amp;lt;int&amp;gt; ptr(n... </summary> </entry> <entry><title>构造-析构-赋值</title><link href="https://weirme.github.io/posts/%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC/" rel="alternate" type="text/html" title="构造-析构-赋值" /><published>2022-05-16T10:08:00+08:00</published> <updated>2022-05-27T22:57:40+08:00</updated> <id>https://weirme.github.io/posts/%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC/</id> <content src="https://weirme.github.io/posts/%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC/" /> <author> <name>weirme</name> </author> <category term="Notes" /> <category term="C/C++" /> <summary> 了解 C++ 默默编写并调用哪些函数 C++ 能够自动生成默认的构造函数, 析构函数, 复制构造函数和赋值运算符. 这些函数都被声明为 public 和 inline, 且仅当它们需要被调用时才会被生成. 示例代码如下: Empty e1; // 生成默认构造函数 Empty e2(e1); // 生成默认复制构造函数 Empty e3 = e2; // 生成默认复制构造函数 e1 = e3; // 生成默认赋值运算符 而一旦在类中声明了一个构造函数, 无论其是否带有参数, 编译器都不会再为这个类生成默认构造函数. 编译器生成的复制构造函数和赋值运算符中, 通常只负责把对象中的每一个 non-static 成员拷贝到目标对象中. 因此一旦类的成员中包含 引用或常量类型 等不可修改的成员变量时, 编译器将无法生成默认的函数. 拒绝编译器自动生... </summary> </entry> <entry><title>从 C 到 C++</title><link href="https://weirme.github.io/posts/%E4%BB%8EC%E5%88%B0C++/" rel="alternate" type="text/html" title="从 C 到 C++" /><published>2022-05-15T14:50:00+08:00</published> <updated>2022-05-17T20:53:40+08:00</updated> <id>https://weirme.github.io/posts/%E4%BB%8EC%E5%88%B0C++/</id> <content src="https://weirme.github.io/posts/%E4%BB%8EC%E5%88%B0C++/" /> <author> <name>weirme</name> </author> <category term="Notes" /> <category term="C/C++" /> <summary> enum hack 在 C++ 中, 大部分宏定义常量可以通过 const 关键字替换, 一个例外是在 class 编译期间需要使用一个 class 常量, 这种情况可以利用 enum 类型来实现替换. 其理论基础在于, 一个属于枚举类型的数值可以被视为 int 型来使用. 例如下面的类定义: class GamePlayer { private: enum { num_turns = 5 }; int scores[num_turns]; ... }; 与 #define 类似, 对 enum 取地址是不合法的. 如果 不想让别人获得一个指针或引用指向某个整数常量 , 可以通过 enum 来实现. 使用 const const_iterator 迭代器的作用类似于 T*, 因此将迭代器声明为 const, 相当于声明一个 T* con... </summary> </entry> <entry><title>Python Mathematic Modules</title><link href="https://weirme.github.io/posts/Python-Mathematics-Modules/" rel="alternate" type="text/html" title="Python Mathematic Modules" /><published>2018-08-20T00:00:00+08:00</published> <updated>2018-08-20T00:00:00+08:00</updated> <id>https://weirme.github.io/posts/Python-Mathematics-Modules/</id> <content src="https://weirme.github.io/posts/Python-Mathematics-Modules/" /> <author> <name>weirme</name> </author> <category term="Notes" /> <category term="Python" /> <summary> numpy Import It is common to import numpy under a briefer name np and also import some class frequently used like array. Common import as follows: import numpy as np from np import array Array Ways to create and some properties We use array() function to generate an array object with a list as parameter. (The list can be multdimensional with nested [] operator.) The shape property of a... </summary> </entry> <entry><title>Radial Basic Function Network</title><link href="https://weirme.github.io/posts/Radial-Basic-Function-Network/" rel="alternate" type="text/html" title="Radial Basic Function Network" /><published>2018-08-19T00:00:00+08:00</published> <updated>2022-05-15T16:13:34+08:00</updated> <id>https://weirme.github.io/posts/Radial-Basic-Function-Network/</id> <content src="https://weirme.github.io/posts/Radial-Basic-Function-Network/" /> <author> <name>weirme</name> </author> <category term="Notes" /> <category term="Machine Learning" /> <summary> RBF Network Learning Firstly we consider the Gaussian SVM which map our data to a infinite-dimensional space \[g_\text{SVM}(\boldsymbol x) = \text{sign}\left(\sum_\text{SV}\alpha_ny_n\exp(-\gamma\Vert\boldsymbol x-\boldsymbol x_n\Vert^2)+b\right) \tag{12.1}\] here Gaussian kernel is also called Radial Basis Function(RBF) and radial means this model only depends on distance between $\boldsymb... </summary> </entry> </feed>
