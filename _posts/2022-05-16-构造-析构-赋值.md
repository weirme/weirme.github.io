---
layout: post
title: 构造-析构-赋值
date: 2022-05-16 10:08 +0800
category: [Notes, C/C++]
tags: [effective C++]
---

## 了解 C++ 默默编写并调用哪些函数

C++ 能够自动生成默认的构造函数, 析构函数, 拷贝构造函数和赋值运算符. 这些函数都被声明为 `public` 和 `inline`, 且仅当它们需要被调用时才会被生成. 示例代码如下:

```cpp
Empty e1;       // 生成默认构造函数
Empty e2(e1);   // 生成默认拷贝构造函数
Empty e3 = e1;  // 生成默认赋值运算符
```

而一旦在类中声明了一个构造函数, 无论其是否带有参数, 编译器都不会再为这个类生成默认构造函数.

编译器生成的拷贝构造函数和赋值运算符中, 通常只负责把对象中的每一个 non-static 成员拷贝到目标对象中. 因此一旦类的成员中包含 **引用或常量类型** 等不可修改的成员变量时, 编译器将无法生成默认的函数.

## 拒绝编译器自动生成函数

如果需要实现一个不支持拷贝操作的类, 一种方法是将这两个函数声明为 `private` 并且不实现它们, 这样如果有人试图拷贝该类的对象时, 就会得到一个链接错误.

而另一种方法是声明如下的一个基类 `Uncopyable`:

```cpp
class Uncopyable {
protected:
    Uncopyable() {}
    ~Uncopyable() {}
private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
};
```

这个基类允许子类生成其对象, 但一旦试图拷贝, 就会发生编译错误. 为了阻止某个类的对象被拷贝, 只需让该类继承 `Uncopyable` 类即可.

## 关于 virtual 析构函数

> 当类中包含至少一个虚函数时, 表明该类带有多态性质, 那么就 **应该** 为它声明虚析构函数; 而在其它情况下, 都 **不应该** 为它声明虚析构函数.
{: .prompt-tip}

在 C++ 中, 标准 `string` 类和 STL 中的容器类都不带有虚析构函数, 因此不能将其用于多态的用途, 更不应该试图继承它们.

有时我们需要拥有一个抽象类, 但手上没有任何纯虚函数, 这时可以将析构函数声明为纯虚函数. 示例代码如下:

```cpp
class AWOV {
public:
    virtual ~AWOV() = 0;
};
```

需要注意的是, **必须** 为这个纯虚析构函数提供一个定义, 否则当其被调用时会出现链接错误.